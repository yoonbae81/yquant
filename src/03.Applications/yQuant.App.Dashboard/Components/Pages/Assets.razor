@page "/assets"
@page "/assets/{AccountAlias}"
@attribute [Microsoft.AspNetCore.Authorization.Authorize]

@using yQuant.Core.Models
@implements IDisposable

@using yQuant.App.Dashboard.Services
@using yQuant.Core.Ports.Output.Infrastructure
@inject AssetService AssetService
@inject AccountCacheService AccountCacheService
@inject StockService StockService
@inject NavigationManager NavigationManager
@inject OrderPublisher OrderPublisher
@inject ISnackbar Snackbar
@inject Microsoft.Extensions.Configuration.IConfiguration Configuration

<AccountSelector Accounts="_availableAccounts" SelectedAccountAlias="@AccountAlias"
    SelectedAccountAliasChanged="@OnAccountChanged" />


@if (account == null)
{
    @if (!string.IsNullOrEmpty(AccountAlias))
    {
        <MudProgressCircular Color="Color.Primary" Indeterminate="true" />
    }
    else
    {
        <MudText>Please select an account.</MudText>
    }
}
else
{
    <MudGrid>
    <MudItem xs="12" sm="6" md="4">
        <MudCard>
            <MudCardContent>
                <MudText Typo="Typo.h6">Total Equity (KRW)</MudText>
                <MudText Typo="Typo.h4">@account.GetTotalEquity(CurrencyType.KRW).ToString("N0") KRW</MudText>
            </MudCardContent>
        </MudCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <MudCard>
            <MudCardContent>
                <MudText Typo="Typo.h6">Total Equity (USD)</MudText>
                <MudText Typo="Typo.h4">@account.GetTotalEquity(CurrencyType.USD).ToString("N2") USD</MudText>
            </MudCardContent>
        </MudCard>
    </MudItem>
    <MudItem xs="12" sm="6" md="4">
        <MudCard>
            <MudCardContent>
                <MudText Typo="Typo.h6">Account Info</MudText>
                <MudText><b>Alias:</b> @account.Alias</MudText>
                <MudText><b>Number:</b> @account.Number</MudText>
            </MudCardContent>
        </MudCard>
    </MudItem>

    <MudItem xs="12">
        <MudText Typo="Typo.h5" GutterBottom="true" Class="mt-4">Deposits</MudText>
        <MudTable Items="@account.Deposits" Hover="true" Breakpoint="Breakpoint.Sm">
            <HeaderContent>
                <MudTh>Currency</MudTh>
                <MudTh>Amount</MudTh>
            </HeaderContent>
            <RowTemplate>
                <MudTd DataLabel="Currency">@context.Key</MudTd>
                <MudTd DataLabel="Amount">@context.Value.ToString("N2")</MudTd>
            </RowTemplate>
        </MudTable>
    </MudItem>

    <MudItem xs="12">
        <MudText Typo="Typo.h5" GutterBottom="true" Class="mt-4">Positions</MudText>
        <PositionTable Positions="@account.Positions.Values.SelectMany(list => list)" AccountAlias="@account.Alias"
            OnOrderCompleted="RefreshAccount" />
    </MudItem>
</MudGrid>
}

@code {
    [Parameter]
    public string? AccountAlias { get; set; }

    private Account? account;
    private IEnumerable<Account> _availableAccounts = new List<Account>();

    @inject UiStateService UiStateService

    @inject RealtimeEventService RealtimeEventService

    protected override async Task OnInitializedAsync()
    {
        RealtimeEventService.OnAccountSynced += HandleAccountSynced;

        await LoadAccounts();

        if (string.IsNullOrEmpty(AccountAlias))
        {
            if (!string.IsNullOrEmpty(UiStateService.SelectedAccountAlias))
            {
                AccountAlias = UiStateService.SelectedAccountAlias;
                // Navigate to properly reflect the state in URL
                var pathBase = Configuration.GetValue<string>("Dashboard:PathBase")?.TrimEnd('/') ?? "";
                NavigationManager.NavigateTo($"{pathBase}/assets/{AccountAlias}", replace: true);
            }
            else if (_availableAccounts.Any())
            {
                AccountAlias = _availableAccounts.First().Alias;
                UiStateService.SetAccount(AccountAlias);
            }
        }
        else
        {
            UiStateService.SetAccount(AccountAlias);
        }

        if (!string.IsNullOrEmpty(AccountAlias))
        {
            await LoadAccountData(AccountAlias);
        }
    }

    public void Dispose()
    {
        RealtimeEventService.OnAccountSynced -= HandleAccountSynced;
    }

    private async void HandleAccountSynced(string alias)
    {
        if (alias == AccountAlias)
        {
            await InvokeAsync(async () =>
            {
                await LoadAccountData(alias);
                StateHasChanged();
            });
        }
    }

    private async Task LoadAccounts()
    {
        _availableAccounts = await AccountCacheService.GetAccountsAsync();
        // Fallback logic moved to OnInitializedAsync
    }

    private async Task OnAccountChanged(string alias)
    {
        AccountAlias = alias;
        UiStateService.SetAccount(alias);
        var pathBase = Configuration.GetValue<string>("Dashboard:PathBase")?.TrimEnd('/') ?? "";
        NavigationManager.NavigateTo($"{pathBase}/assets/{alias}"); // Update URL
        await LoadAccountData(alias);
    }

    private async Task LoadAccountData(string alias)
    {
        account = await AssetService.GetAccountOverviewAsync(alias);
        // Stock names are now handled within PositionTable component
    }

    private async Task RefreshAccount()
    {
        // No longer relying on Task.Delay.
        // We wait for the "AccountSynced" event from RealtimeEventService.
        // However, for immediate optimistic UI feedback or manual refreshes, simple reload is fine.
        // If this is triggered by PositionTable after an order, the backend will send an event eventually.
        // But to be safe if event is lost, we can do a quick reload or just let the event handle it.
        // Since we are moving to Event-Driven, we can remove the Delay.

        if (!string.IsNullOrEmpty(AccountAlias))
        {
            // Optional: trigger reload immediately in case optimistic updates happened?
            // But the main goal was to wait for broker sync.
            // If we remove delay, we might show old data if sync isn't done.
            // But PositionTable triggers this "OnOrderCompleted".
            // If we just return, the event will eventually come.
            // Let's keep a simple reload but without delay, or rely purely on event.
            // If we rely purely on event, user might see nothing happening for 3 seconds.
            // That's acceptable for "Debounced Sync".
            // But "PositionTable" might want to show "Processing..." state?
            // For now, let's just do nothing here and let HandleAccountSynced do the work.
            // Or better, just reload immediately to catch any partial updates.
            await LoadAccountData(AccountAlias);
            StateHasChanged();
        }
    }
}